\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{enumerate}
\usepackage{algorithmic}

\author{Pierre Gimalac \& Alexandre Moine\\\small{Encadré par François Laroussinie}}
\title{Rapport de Projet\\Mathématiques-Informatique}
\begin{document}
\maketitle

\section{CTL, une logique temporelle}
\subsection{Définition}
CTL (pour \textit{Computation Tree Logic}) est une logique temporelle ; CTL contient la logique propositionnelle usuelle et ajoute des opérateurs temporels.

Elle permet par exemple d'exprimer des propriétés comme ``il existe une exécution telle que la variable \textit{a} soit toujours vraie''.

\subsection{Grammaire}
La grammaire de CTL est définie de la manière suivante :
\begin{align*}
\phi &::= \bot \mid \top \mid p \mid \neg \phi \mid \phi\land\phi \mid \phi\lor\phi \mid \\
&\quad \mbox{AX }\phi \mid \mbox{EX }\phi \mid
\mbox{A }\phi \mbox{ W } \phi \mid \mbox{E }\phi \mbox{ W } \phi \mid
\mbox{A }\phi \mbox{ U } \phi \mid \mbox{E }\phi \mbox{ U } \phi
\end{align*}

Ici, $p$ représente une proposition atomique d'un ensemble $\Omega$.

On définit aussi d'autres opérateurs utiles :
\begin{itemize}
	\item $\mbox{AF } \phi := \mbox{A } \top \mbox{ U } \phi$
	\item $\mbox{EG } \phi := \neg (\mbox{AF } (\neg \phi))$
	\item $\mbox{EF } \phi := \mbox{E } \top \mbox{ U } \phi$
	\item $\mbox{AG } \phi := \neg (\mbox{EF } (\neg \phi))$
\end{itemize}

\subsection{Sémantique de CTL}
Les modèles de CTL sont appelés des \emph{structures de Kripke}.

\subsubsection{Structures de Kripke}
Une structure de Kripke sera ici identifiée à la donnée de $(Q,T,q_0,l)$ où:
\begin{itemize}
\item Le couple $(Q,T, q_0)$ est un graphe orienté étiqueté : $Q$ est un ensemble d'états, $T \subseteq Q \times Q$ est la relation de transition et $q_0 \in Q$ représente l'état de départ.
\item $l : \mathcal{P}(Q) \to \Omega$ est une fonction d'étiquetage.
\end{itemize}

\subsubsection{Exécution}
Soit $\mathcal{A} = (Q,T,q_0,l)$ une structure de Kripke.
On dira que $\sigma : \mathbb{N} \to Q$ est une \emph{exécution} de $\cal{A}$ (ne partant pas forcément de l'état initial) si et seulement si $\forall i \in \mathbb{N}, (\sigma (i), \sigma (i+1)) \in T$. 
\\
On note $Exec(\mathcal{A})$ l'ensemble des exécutions sur $\mathcal{A}$.

\subsubsection{Satisfaction}
Soit $\mathcal{A} = (Q,T,q_0,l)$ une structure de Kripke et $\phi$ une formule de CTL.\\
Soit $i\in \mathbb{N}$, On dira qu'il existe une exécution de $\mathcal{A}$ vérifiant $\phi$ depuis l'état $q_i$ si et seulement si $A, q_i \vDash \phi$. On omettra souvent la donnée de $\mathcal{A}$ dans notre écriture.\\
On définit $q_i \vDash \phi$ par induction sur $\phi$:\\
\\
\begin{tabular}{lcl}
$q_i \nvDash \bot$ &&\\
$q_i \vDash \top$ &&\\
$q_i \vDash p$ &ssi& $p \in l (q_i)$\\
$q_i \vDash \neg \psi$ &ssi& $q_i \nvDash \psi$\\
$q_i \vDash \psi_1 \land \psi_2$ &ssi& $q_i \vDash \psi_1$ et $q_i \vDash \psi_2$\\
$q_i \vDash \psi_1 \lor \psi_2$ &ssi& $q_i \vDash \psi_1$ ou $q_i \vDash \psi_2$\\
$q_i \vDash \mbox{EX } \psi$ &ssi& $\exists (q_i, q_j) \in T$, $q_j \vDash \psi$\\
$q_i \vDash \mbox{AX } \psi$ &ssi& $\forall (q_i, q_j) \in T$, $q_j \vDash \psi$\\

$q_{i} \vDash \mbox{E } \psi_1 \mbox{ U } \psi_2$ &ssi& $\exists \sigma: \sigma(0) = q_i$, $\exists k \in \mathbb{N}$, $\sigma(k)\vDash \psi_2$ $\land$ $\forall j \in \llbracket 0; k\llbracket, \sigma(j)\vDash \psi_1$\\

$q_i \vDash \mbox{A } \psi_1 \mbox{ U } \psi_2$ &ssi& $\forall \sigma: \sigma(0) = q_i$, $\exists k \in \mathbb{N}$, $\sigma(k)\vDash \psi_2$ $\land$ $\forall j \in \llbracket 0; k\llbracket, \sigma(j)\vDash \psi_1$\\

$q_i \vDash \mbox{E } \psi_1 \mbox{ W } \psi_2$ &ssi& $\exists \sigma : \sigma(0) = q_i$, soit $\exists k\in \mathbb{N}$: $\sigma(k)\vDash \psi_2$ et $\forall j \in \llbracket i; k \llbracket$: $\sigma(j) \vDash \psi_1$\\
& & soit $\forall j \in \mathbb{N}$, $\sigma(j) \vDash \psi_1$\\

$q_i \vDash \mbox{A } \psi_1 \mbox{ W } \psi_2$ &ssi& $\forall \sigma : \sigma(0) = q_i$, soit $\exists k\in \mathbb{N}$: $\sigma(k)\vDash \psi_2$ et $\forall j \in \llbracket i; k \llbracket$: $\sigma(j) \vDash \psi_1$\\
& & soit $\forall j \in \mathbb{N}$, $\sigma(j) \vDash \psi_1$\\
\end{tabular}

\bigskip

La sémantique de CTL se comprend aussi bien en français:

\begin{tabular}{lcl}
$q_i \vDash \top$ && est toujours vrai\\
$q_i \vDash \bot$ && n'est jamais vrai\\
$q_i \vDash p$ &ssi& $p$ est une étiquette de $\sigma(i)$\\
$q_i \vDash \neg \psi$ &ssi& $q_i$ ne vérifie pas $\phi$\\
$q_i \vDash \psi_1 \land \psi_2$ &ssi& $q_i$ vérifie $\phi_1$ et $q_i$ vérifie $\phi_2$\\
$q_i \vDash \psi_1 \lor \psi_2$ &ssi& $q_i$ vérifie $\phi_1$ ou $q_i$ vérifie $\phi_2$\\
$q_i \vDash \mbox{EX } \psi$ &ssi& il existe un successeur de $q_i$ vérifiant $\psi$\\
$q_i \vDash \mbox{AX } \psi$ &ssi& tous les successeurs de $q_i$ vérifient $\psi$\\
$q_i \vDash \mbox{E } \psi_1 \mbox{ U } \psi_2$ &ssi& il existe un chemin à partir de $\sigma(i)$ tel que $\psi_1$\\&& est vrai jusqu'à ce que $\psi_2$ le soit (et il le sera un jour)\\

$q_i \vDash \mbox{A } \psi_1 \mbox{ U } \psi_2$ &ssi& pour tout chemin partant de $q_i$, $\psi_1$ est vrai \\&& jusqu'à ce que $\psi_2$ le soit (et il le sera un jour)\\

$q_i \vDash \mbox{E } \psi_1 \mbox{ W } \psi_2$ &ssi& il existe un chemin à partir de $q_i$ tel que $\psi_1$\\&& est vrai jusqu'à ce que, peut-être, $\psi_2$ le soit\\

$q_i \vDash \mbox{A } \psi_1 \mbox{ W } \psi_2$ &ssi& pour tout chemin partant de $q_i$, $\psi_1$ est vrai \\&& jusqu'à ce que, peut-être, $\psi_2$ le soit\\
\end{tabular}

\subsection{Négation}
On peut définir la fonction $desc\_neg:CTL \to CTL$ qui permet de transformer une formule de CTL en formule équivalente où toutes les négations sont sur les littéraux :
\begin{align*}
&desc\_neg(\top) = \top \quad desc\_neg(\bot) = \bot\\
&desc\_neg(p) = p \\
&desc\_neg(\neg \phi) = neg(\phi)\\
&desc\_neg(a \lor b) = desc\_neg(a) \lor desc\_neg(b)\\
&desc\_neg(a \land b) = desc\_neg(a) \land desc\_neg(b)\\
&desc\_neg(\mbox{EX } \phi) = \mbox{EX }desc\_neg(\phi)\\
&desc\_neg(\mbox{AX } \phi) = \mbox{AX }desc\_neg(\phi)\\
&desc\_neg(\mbox{E } \phi \mbox{ U } \psi) =\mbox{E } desc\_neg(\phi) \mbox{ U } desc\_neg(\psi)\\
&desc\_neg(\mbox{A } \phi \mbox{ U } \psi) =\mbox{A } 
desc\_neg(\phi) \mbox{ U } desc\_neg(\psi)\\
&desc\_neg(\mbox{E } \phi \mbox{ W } \psi) =\mbox{E } desc\_neg(\phi) \mbox{ W } desc\_neg(\psi)\\
&desc\_neg(\mbox{A } \phi \mbox{ W } \psi) =\mbox{A } desc\_neg(\phi) \mbox{ W } desc\_neg(\psi)
\end{align*}

\begin{align*}
&neg(\top) = \bot \quad neg(\bot) = \top\\
&neg(p) = \neg p \quad neg(\neg \phi) = desc\_neg(\phi)\\
&neg(a \lor b) = neg(a) \land neg(b)\\
&neg(a \land b) = neg(a) \lor neg(b)\\
&neg(\mbox{EX } \phi) = \mbox{AX }neg(\phi)\\
&neg(\mbox{AX } \phi) = \mbox{EX }neg(\phi)\\
&neg(\mbox{E } \phi \mbox{ U } \psi) =\mbox{A } (neg(\psi)) \mbox{ W } (neg(\phi) \land neg(\psi))\\
&neg(\mbox{A } \phi \mbox{ U } \psi) =\mbox{E } (neg(\psi)) \mbox{ W } (neg(\phi) \land neg(\psi))\\
&neg(\mbox{E } \phi \mbox{ W } \psi) =\mbox{A } (neg(\psi)) \mbox{ U } (neg(\phi) \land neg(\psi))\\
&neg(\mbox{A } \phi \mbox{ W } \psi) =\mbox{E } (neg(\psi)) \mbox{ U } (neg(\phi) \land neg(\psi))
\end{align*}

\section{Model-checking de CTL: jeux faibles de parité}
Le but ici est de parvenir à créer un jeu à partir d'une formule et d'une structure de Kripke où deux joueurs (nommés Ève et Adam) s'affrontent, et Ève gagne si et seulement si la formule est vraie dans la structure donnée.

\subsection{Jeux de parité}
On appelle \emph{jeu de parité} un quadruplet $G = (V_E, V_A, R, c)$ où:
\begin{itemize}
\item $V_E$ (respectivement $V_A$) est l'ensemble des états jouables par Ève (respectivement Adam). On demande de plus que $V_e \cap V_a = \emptyset$. On note $V = V_e \sqcup V_a$.
\item $R \subseteq V \times V$ est une relation de transition.
\item $c : V \to (\mathbb{N} \cup \{\bot\})$ est une fonction qui associe une couleur ou $\bot$ à chaque état.
\end{itemize}

\subsubsection{Victoire}
Une partie d'un jeu est une fonction $\omega : V' \to V, V' \subseteq V$ telle que $\forall v \in V', (v,\omega(v)) \in R$.
Une partie à partir d'un état $q_0 \in V$ est gagnée par:
\begin{itemize}
\item Ève si est seulement si:
	\begin{itemize}
	\item Soit Adam est bloqué : $\exists n \in \mathbb{N}, \omega^n (q_0) \in V_A \land \omega^{n+1} (q_0) \notin V'$.
	\item Soit Ève visite infiniment souvent des états uniquement pairs: $\exists n \in \mathbb{N}, \forall m \geq n, (\omega^m(q_0) \in V_E \land c(\omega^m(q_0)) \neq \bot )\implies c(\omega^m(q_0)) = 0 \mod 2$.
	\end{itemize}
\item Adam si est seulement si:
\begin{itemize}
	\item Soit Ève est bloquée : $\exists n \in \mathbb{N}, \omega^n (q_0) \in V_E \land \omega^{n+1} (q_0) \notin V'$.
	\item Soit Adam visite infiniment souvent des états uniquement impairs: $\exists n \in \mathbb{N}, \forall m \geq n, (\omega^m(q_0) \in V_E \land c(\omega^m(q_0)) \neq \bot )\implies c(\omega^m(q_0)) = 1 \mod 2$.
\end{itemize}
\end{itemize}

\subsubsection{Stratégie}
On note $V^*$ l'ensemble $\{v \in V | \exists v' \in V, (v,v') \in R\}$.
On appelle une stratégie pour Ève (respectivement Adam) une fonction $\rho : V_E^* \to V$ (respectivement $\rho : V_A^* \to V$).

On appelle stratégie \emph{induite} par $\rho : V_E^* \to V$ et $\rho' : V_A^* \to V$, la fonction $\omega : (V_E^* \cup V_A^* \to V)$ définie par:
\\
$$\omega(v) \left \{
\begin{array}{rcl}
\rho(v) & si & v \in V_E^*\\
\rho'(v) & si & v \in V_A^*\\
\end{array}
\right .$$
Une stratégie $\rho$ est dite gagnante pour Ève (respectivement Adam) si et seulement si pour toute stratégie $\rho'$ pour Adam (respectivement Ève), la partie induite par $\rho$ et $\rho'$ est gagnante pour Ève (respectivement Adam).

\subsection{Jeux faibles de parité}
\label{fpg}

On dit qu'un jeu de parité $G = (V_E,V_A,R,c)$ est \emph{faible}  si et seulement si il existe $V_1$, ..., $V_k$ une partition de $V = V_E \sqcup V_A$ telle que:
\begin{enumerate}[a)]
\item La couleur soit la même pour tous les états d'une classe de la partition : $\forall i \in \llbracket 1 ; k \rrbracket$, $\forall x, y \in V_i$, $(c(x) \neq \bot \land c(y) \neq \bot)  \implies c(x) = c(y)$
\item La partition représente une convergence du jeu :\\
$\forall (x, y) \in R$, $x\in V_i, y \in V_j \Rightarrow i \leq j$.
\end{enumerate}

\subsection{Algorithme de construction du jeu}
Nous allons maintenant définir un algorithme qui permet de construire un jeu de parité à partir d'une formule de CTL et d'une structure de Kripke. Nous allons ensuite montrer que ce jeu est \emph{faible} et que Ève gagne si et seulement si la formule est vraie dans la structure. Plus précisément, nous allons donner ici la fonction de transition du jeu.

Soit $\phi$ une formule de CTL et $K = (Q,T,q_0,l)$  une structure de Kripke.
On va construire un jeu de parité $G = (V_E,V_A,R,c)$ où:
\begin{itemize}
	\item $V = Q \times SF(\phi)$
	\item $V_A = \{(i, \top ) \in V\} \cup \{(i, \phi) \in V, \phi = \phi_1 \land \phi_2 \mid \mbox{AX } \phi_1\mid \mbox{A } \phi_1 \mbox{ U } \phi_2 \mid \mbox{A } \phi_1 \mbox{ W } \phi_2\}$
	\item $V_E = V \backslash V_A$
	\item $\forall (s,v) \in V, c(s,v) = \left \{
	\begin{array}{rcl}
		2 & si & \text{v = EW ou AW}\\
		1 & si & \text{v = EU ou AU}\\
		\bot && sinon
	\end{array}
	\right .$
\end{itemize}

\bigskip

On peut maintenant définir $R$, la relation de transition, en définissant la fonction $succ : V \to P(V)$ qui à un état associe la liste de ses successeurs.\\

On définit $succ$:
\begin{itemize}
\item$ succ(s, \bot) = succ(s, \top) = \emptyset$
\item $succ(s, p) = \{(s,\top)\}$ si $p \in l(s)$, $\{(s,\bot)\}$ sinon
\item $succ(s, \neg p) = \{(s,\bot)\}$ si $p \in l(s)$, $\{(s,\top)\}$ sinon
\item $succ(s,\phi \land \psi) = succ(s, \phi \lor \psi) = \{(s,\phi), (s,\psi) \}$
\item $succ(s,EX \phi) = succ(s, AX \phi) = \{ (s', \phi) \mid (s,s') \in T \} $
\item $succ(s, \mbox{E } \phi \mbox{ U } \psi) = \{ (s,\psi), (s, \phi \land \mbox{EX }  (\mbox{E } \phi \mbox{ U } \psi)) \}$
\item $succ(s, \mbox{A } \phi \mbox{ U } \psi) = \{ (s,\psi), (s, \phi \land \mbox{AX }  (\mbox{A } \phi \mbox{ U } \psi)) \}$
\item $succ(s, \mbox{E } \phi \mbox{ W } \psi) = \{ (s,\psi), (s, \phi \land \mbox{EX }  (\mbox{E } \phi \mbox{ W } \psi)) \}$
\item $succ(s, \mbox{A } \phi \mbox{ W } \psi) = \{ (s,\psi), (s, \phi \land \mbox{AX } (\mbox{A } \phi \mbox{ W } \psi)) \}$
\end{itemize}

\subsubsection{Jeu faible}
Montrons que le jeu défini par $succ$ avec comme état initial $start = (q_0, \phi)$.
 est un jeu \emph{faible}, donc qu'il existe une partition finie de $V$ telle que a) et b) (définies en Section \ref{fpg}) soient vraies.

On identifie le jeu à un graphe et on va montrer que la partition $V_1, \dots, V_k$ des composantes fortement connexes dans un ordre topologique satisfait les conditions. On note que les CFC forment un graphe acyclique.

\begin{enumerate}[a)]
\item $\forall i \in \llbracket 1 ; k \rrbracket$, $\forall x,y \in V_i$ tel que $x \neq y$ et $c(x) \neq \bot$ et $c(y) \neq \bot$. Si $V_i$ ne contient qu'un seul état, le résultat vrai. Sinon, $V_i$ est une CFC non triviale et, à la vue de la définition de $succ$ elle est de la forme suivante : $\{ \phi; \mbox{EX }\phi \}$ avec $\mbox{X } \psi_1 \mbox{ Y } \psi_2$ et $ X=A$ ou $X =E$ et $Y = U$ ou $Y=W$. Donc le résultat est vrai.

\item est trivialement vraie: les $V_i$ sont ordonnées par ordre topologique.
\end{enumerate}

\subsubsection{Jeu correct}
Montrons maintenant qu'Ève a une stratégie gagnante dans $G$ si, et seulement si, $\exists \sigma$: $\sigma,q_0 \vDash \phi$.

\paragraph{$\implies$}
On suppose qu'Ève a une stratégie gagnante à partir de $(q_0, \phi)$. On va montrer que $\exists \sigma$: $\sigma,q_0 \vDash \phi$. On procède par récurrence sur $\phi$.

\begin{itemize}
\item $\phi = p$. C'est à Ève de jouer et $succ(q_0,\phi) = \{(q_0, \top)\}$ ou $succ(q_0,\phi) = \{(q_0, \bot)\}$. Il y a donc une seule exécution possible, $\sigma$. Comme Ève a une stratégie gagnante, c'est qu'elle n'est pas bloquée dans le prochain état. Donc Adam l'est, donc $succ(q_0,\phi) = \{(q_0, \top)\}$, donc $p \in l(q_0)$ donc, $\sigma,q_0 \vDash \phi$.

\item $\phi = \neg p$. C'est à Ève de jouer et $succ(q_0,\phi) = \{(q_0, \top)\}$ ou $succ(q_0,\phi) = \{(q_0, \bot)\}$. Il y a donc une seule exécution possible, $\sigma$. Comme Ève a une stratégie gagnante, c'est qu'elle n'est pas bloquée dans le prochain état. Donc Adam l'est, donc $succ(q_0,\phi) = \{(q_0, \top)\}$, donc $p \notin l(q_0)$ donc, $\sigma,q_0 \vDash \phi$.

\item $\phi = \psi_2 \lor \psi_2$. On a donc $succ(q_0,\phi) = \{(q_0, \psi_1); (q_0, \psi_2) \}$ et c'est à Ève de jouer. Comme Ève a une stratégie gagnante, elle choisit dans quel état aller, mettons $(q_o, \psi_1)$. Elle a donc une stratégie gagnante à partir de $(q_0, \psi_1)$, donc par hypothèse de récurrence, $\exists \sigma$: $\sigma,q_0 \vDash \psi_1$. Donc $\sigma,q_0 \vDash \phi$. Il en va de même si Ève choisit d'aller en $(q_o, \psi_2)$.

\item $\phi = \psi_2 \land \psi_2$. On a donc $succ(q_0,\phi) = \{(q_0, \psi_1); (q_0, \psi_2) \}$ et c'est à Adam de jouer. Comme Ève a une stratégie gagnante, quel que soit l'état que choisit Adam, elle a une stratégie gagnante à partir de ce nouvel état, donc par hypothèse de récurrence, $\exists \sigma$: $\sigma,q_0 \vDash \psi_1$ et $\sigma,q_0 \vDash \psi_2$ . Donc $\sigma,q_0 \vDash \phi$.

\item $\phi = \mbox{EX } \psi$. Donc $succ(q_0, \phi) = \{ (q, \psi) \mid (q_0,q) \in T \} $ et c'est à Ève de jouer. Comme elle a une stratégie gagnante, il existe un successeur $q$ de $q_0$ tel qu'elle ait une stratégie gagnante à partir de $q$ et donc par récurrence que $\sigma \circ (+ 1), q \vDash \psi$. Donc $\sigma, q_0 \vDash \phi$.

\item $\phi = \mbox{AX } \psi$. Donc $succ(q_0, \phi) = \{ (q, \psi) \mid (q_0,q) \in T \} $ et c'est à Adam de jouer. Comme Ève a une stratégie gagnante, pour tous les successeurs $q$ de $q_0$, elle une stratégie gagnante à partir de $q$ et donc par récurrence que $\sigma \circ (+ 1), q \vDash \psi$. Donc $\sigma, q_0 \vDash \phi$.

\item $\phi = \mbox{E } \psi_1 \mbox{ W } \psi_2$. Donc $succ(\phi) = \{ (s,\psi_2), (s, \psi_1 \land \phi) \}$. Ève a une stratégie gagnante, deux cas sont possibles :
\begin{itemize}
	\item Soit Ève choisit $(s,\psi_2)$, et par hypothèse de récurrence $\sigma, q_0 \vDash \psi_2$ et donc $\sigma, q_0 \vDash \phi$.
	\item Soit Ève choisit TODO
\end{itemize}
\end{itemize}

\paragraph{$\Longleftarrow$}
Soit $\sigma$ tel que $\sigma,q_0 \vDash \phi$. On doit en déduire une stratégie gagnante pour Ève.\\
On procède par récurrence sur $\phi$ :
\begin{itemize}
\item $\phi = p$, c'est à Ève de jouer et comme $\sigma,q_0 \vDash \phi$, cela veut dire que $p \in l(q_0)$, donc $succ(q_0,\phi) = \{(q_0, \top)\}$, donc Adam est bloqué, donc Ève gagne.
\item $\phi = \neg p$, c'est à Ève de jouer et comme $\sigma,q_0 \vDash \phi$, cela veut dire que $p \notin l(q_0)$, donc $succ(q_0,\phi) = \{(q_0, \top)\}$, donc Adam est bloqué, donc Ève gagne.

\item $\phi = \psi_2 \lor \psi_2$. On a donc $succ(q_0,\phi) = \{(q_0, \psi_1); (q_0, \psi_2) \}$ et c'est à Ève de jouer. Comme $\sigma,q_0 \vDash \phi$, $\sigma,q_0 \vDash \psi_1$ ou $\sigma,q_0 \vDash \psi_2$. Si, par exemple, $\sigma,q_0 \vDash \psi_1$, par hypothèse de récurrence, on a qu'Ève a une stratégie gagnante à partir de l'état $(q_0, \psi_1)$. Ève peut donc choisir d'aller dans cet état, et elle gagne. On procède de la même façon si $(q_0, \psi_2)$.

\item $\phi = \psi_2 \land \psi_2$. On a donc $succ(q_0,\phi) = \{(q_0, \psi_1); (q_0, \psi_2) \}$ et c'est à Adam de jouer. Comme $\sigma,q_0 \vDash \phi$, $\sigma,q_0 \vDash \psi_1$ et $\sigma,q_0 \vDash \psi_2$. On a donc par hypothèse de récurrence, qu'Ève a une stratégie gagnante à partir de l'état $(q_0, \psi_1)$ et à partir de l'état $(q_0, \psi_2)$. Donc, quel que soit le coup que va jouer Adam, Ève a une stratégie gagnante.

\item $\phi = \mbox{EX } \psi$. Donc $succ(s, \phi) = \{ (s', \psi) \mid (s,s') \in T \} $ et c'est à Ève de jouer. Comme $\sigma,q_0 \vDash \phi$, il existe un successeur $q$ de $q_0$ tel que $\sigma\circ (+ 1),q \vDash \psi$. Donc, par hypothèse de récurrence, il existe une stratégie gagnante pour Ève à partir de $(q, \psi)$. Comme c'est à Ève de jouer, il suffit qu'elle joue vers cet état.

\item $\phi = \mbox{AX } \psi$. Donc $succ(q_0, \phi) = \{ (q, \psi) \mid (q_0,q) \in T \} $ et c'est à Adam de jouer. Comme $\sigma,q_0 \vDash \phi$, pour tous les successeurs $q$ de $q_0$, on a que $\sigma\circ (+ 1),q \vDash \psi$. Donc, par hypothèse de récurrence, il existe une stratégie gagnante pour Ève pour chacun des $(q, \psi)$. C'est à Adam de jouer, mais quelque soit son choix, Ève a une stratégie gagnante. Donc Ève a une stratégie gagnante.

\item $\phi = \mbox{E } \psi_1 \mbox{ U } \psi_2$ ou $\phi = \mbox{E } \psi_1 \mbox{ W } \psi_2$. Donc $succ(q_0,\phi) = \{ (q_0,\psi_2), (q_0,\psi_1 \land \mbox{EX }  \phi) \}$ et c'est à Ève de jouer. $\sigma,q_0 \vDash \phi$, il y a donc deux possiblités :
\begin{itemize}
	\item soit $\sigma,q_0 \vDash \psi_2$ et, par hypothèse de récurrence, alors Ève a une stratégie gagnante à partir de $(q_0,\psi_2)$. Il lui suffit donc de choisir cette transition.
	\item TODO
\end{itemize}
Donc Ève a une stratégie gagnante dans tous les cas.

\item $\phi = \mbox{A } \psi_1 \mbox{ U } \psi_2$ ou $\phi = \mbox{A } \psi_1 \mbox{ W } \psi_2$. Donc $succ(q_0,\phi) = \{ (q_0,\psi_2), (q_0,\psi_1 \land \mbox{EX }  \phi) \}$ et c'est à Adam de jouer. $\sigma,q_0 \vDash \phi$, il y a donc deux possibilités :
\begin{itemize}
	\item soit $\sigma,q_0 \vDash \psi_2$ et, par hypothèse de récurrence, alors Ève a une stratégie gagnante à partir de $(q_0,\psi_2)$.
	\item TODO
\end{itemize}
Donc quelque-soit le choix d'Adam, Ève a une stratégie gagnante.
\end{itemize}

\subsection{Résolution des jeux faibles de parité}
Soit $\gamma$ un joueur (Ève ou Adam). On notera par la suite $\overline{\gamma}$ l'autre joueur.

\subsubsection{Procédure principale}
\begin{algorithmic}[1]
	\REQUIRE $(q_0, V, E)$ \COMMENT{l'état de départ et le graphe du jeu}
	\STATE $CFC \leftarrow compute\_cfc(V, E)$
	\STATE $CFC \leftarrow topological\_sort(CFC)$
	\STATE $CFC \leftarrow reverse(CFC)$
	\STATE $winners \leftarrow new\_array(size(V), \bot)$
	\FOR { $V_k \in CFC$ }
		\STATE $\gamma \leftarrow get\_winner(V_k)$
		\STATE $propagate\_opposite(\gamma, V_k, E, winners)$
		\FOR { $x \in V_k$ }
			\IF { $winners[x] = \bot$ }
				\STATE $winners[x] = \gamma$
			\ENDIF
		\ENDFOR
	\ENDFOR
	\RETURN $winners[q_0]$
\end{algorithmic}

\subsubsection{Procédure $propagate\_opposite$}
\begin{algorithmic}[1]
	\REQUIRE $(\gamma, V, E, winners)$
	\STATE $CHANGED \leftarrow FALSE$
	\FOR{$x \in V$}
		\IF{$winners[x] = \bot$}
			\STATE $EXI \leftarrow FALSE$
			\STATE $ALL \leftarrow TRUE$
			\FOR {$(x,y) \in E$}
				\IF{$winners[y] = \overline{\gamma}$}
					\STATE $EXI \leftarrow TRUE$
				\ELSE
					\STATE $ALL \leftarrow FALSE$
				\ENDIF
			\ENDFOR
			\IF{$(get\_player(y) = \overline{\gamma} \land EXI) \lor ALL $}
				\STATE $CHANGED \leftarrow TRUE$
				\STATE $winners[y] = \overline{\gamma}$
			\ENDIF
		\ENDIF
	\ENDFOR
	\IF{$CHANGED$}
		\STATE $propagate\_opposite(\gamma, V, E, winners)$
	\ENDIF
	\RETURN
\end{algorithmic}

\subsection{Correction}

\end{document}

\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{enumerate}

\author{Pierre Gimalac \& Alexandre Moine\\\small{Encadré par François Laroussinie}}
\title{Rapport de Projet\\Mathématiques-Informatique}
\begin{document}
\maketitle

\section{CTL, une logique temporelle}
\subsection{Définition}
CTL (pour \textit{Computation Tree Logic}) est une logique temporelle ; CTL contient la logique propositionnelle usuelle et ajoute des opérateurs temporels.

Elle permet par exemple d'exprimer des propriétés comme ``il existe une exécution telle que la variable \textit{a} soit toujours vraie''.

\subsection{Grammaire}
La grammaire de CTL est définie de la manière suivante :
\begin{align*}
\phi &::= \bot \mid \top \mid p \mid \neg \phi \mid \phi\land\phi \mid \phi\lor\phi \mid \\
&\quad \mbox{AX }\phi \mid \mbox{EX }\phi \mid
\mbox{A }\phi \mbox{ W } \phi \mid \mbox{E }\phi \mbox{ W } \phi \mid
\mbox{A }\phi \mbox{ U } \phi \mid \mbox{E }\phi \mbox{ U } \phi
\end{align*}

Ici, $p$ représente une proposition atomique d'un ensemble $\Omega$.

On définit aussi d'autres opérateurs utiles :
\begin{itemize}
	\item $\mbox{AF } \phi := \mbox{A } \top \mbox{ U } \phi$
	\item $\mbox{EG } \phi := \neg (\mbox{AF } (\neg \phi))$
	\item $\mbox{EF } \phi := \mbox{E } \top \mbox{ U } \phi$
	\item $\mbox{AG } \phi := \neg (\mbox{EF } (\neg \phi))$
\end{itemize}

\subsection{Sémantique de CTL}
Les modèles de CTL sont appelés des \emph{structures de Kripke}.

\subsubsection{Structures de Kripke}
Une structure de Kripke sera ici identifiée à la donnée de $(Q,T,q_0,l)$ où:
\begin{itemize}
\item Le couple $(Q,T, q_0)$ est un automate : $Q$ est un ensemble d'états, $T \subseteq Q \times Q$ est l'ensemble des transitions et $q_0 \in Q$ représente l'état de départ.
\item $l : Q \to \Omega$ est une fonction d'étiquetage.
\end{itemize}

\subsubsection{Exécution}
Soit $\mathcal{A} = (Q,T,q_0,l)$ une structure de Kripke.
On dira que $\sigma : \mathbb{N} \to Q$ est une \emph{exécution} de $\cal{A}$ (ne partant pas forcément de l'état initial) si et seulement si $\forall i \in \mathbb{N}, (\sigma (i), \sigma (i+1)) \in T$.

\subsubsection{Satisfaction}
Soit $\mathcal{A} = (Q,T,q_0,l)$ une structure de Kripke, $\phi$ une formule de CTL et $\sigma$ une exécution de $\mathcal{A}$.\\
Pour tout $i \in \mathbb{N}$, on dira que "$\phi$ est vraie au temps $i$ de l'exécution de $\sigma$" si et seulement si $A,\sigma,i \vDash \phi$. On omettra souvent la donnée de $\mathcal{A}$ dans notre écriture.\\
On définit $\sigma,i \vDash \phi$ par induction sur $\phi$:\\
\\
\begin{tabular}{lcl}
$\sigma,i \nvDash \bot$ &&\\
$\sigma,i \vDash \top$ &&\\
$\sigma,i \vDash p$ &ssi& $p \in l (\sigma(i))$\\
$\sigma,i \vDash \neg \psi$ &ssi& $\sigma,i \nvDash \psi$\\
$\sigma,i \vDash \psi_1 \land \psi_2$ &ssi& $\sigma,i \vDash \psi_1$ et $\sigma,i \vDash \psi_2$\\
$\sigma,i \vDash \psi_1 \lor \psi_2$ &ssi& $\sigma,i \vDash \psi_1$ ou $\sigma,i \vDash \psi_2$\\
$\sigma,i \vDash \mbox{EX } \psi$ &ssi& $\exists \sigma'$, $\forall j \leq i$: $\sigma(j) = \sigma'(j)$ et $\sigma',i+1 \vDash \psi$\\
$\sigma,i \vDash \mbox{AX } \psi$ &ssi& $\forall \sigma'$, $\forall j \leq i$: $\sigma(j) = \sigma'(j)$ et $\sigma',i+1 \vDash \psi$\\

$\sigma,i \vDash \mbox{E } \psi_1 \mbox{ U } \psi_2$ &ssi& $\exists \sigma'$, $\forall j \leq i$: $\sigma(j) = \sigma'(j)$ et\\
& & $\exists k \geq i$: $\sigma',k\vDash \psi_2$ et $\forall n \in \llbracket i; k \llbracket$, $\sigma',n \vDash \psi_1$\\

$\sigma,i \vDash \mbox{A } \psi_1 \mbox{ U } \psi_2$ &ssi& $\forall \sigma'$, $\forall j \leq i$: $\sigma(j) = \sigma'(j)$ et\\
& & $\exists k \geq i$: $\sigma',k\vDash \psi_2$ et $\forall n \llbracket i; k \llbracket$: $\sigma',n \vDash \psi_1$\\

$\sigma,i \vDash \mbox{E } \psi_1 \mbox{ W } \psi_2$ &ssi& $\exists \sigma'$ tel que $\forall j \leq i$: $\sigma(j) = \sigma'(j)$,\\
& & soit $\exists k \geq i$: $\sigma',k\vDash \psi_2$ et $\forall n \in \llbracket i; k \llbracket$: $\sigma',n \vDash \psi_1$\\
& & soit $\forall n \geq i$: $\sigma',n \vDash \psi_1$\\

$\sigma,i \vDash \mbox{A } \psi_1 \mbox{ W } \psi_2$ &ssi& $\forall \sigma'$ tel que $\forall j \leq i$: $\sigma(j) = \sigma'(j)$, \\
& & soit $\exists k \geq i$: $\sigma',k\vDash \psi_2$ et $\forall n \in \llbracket i; k \llbracket$: $\sigma',n \vDash \psi_1$\\
& & soit $\forall n \geq i$: $\sigma',n \vDash \psi_1$\\
\end{tabular}

\subsection{Satisfaction morale}
On peut donner un sens moral aux formules de CTL:\\

\begin{tabular}{lcl}
$\sigma,i \vDash \top$ && est toujours vrai\\
$\sigma,i \vDash \bot$ && n'est jamais vrai\\
$\sigma,i \vDash p$ &ssi& $p$ est une étiquette de $\sigma(i)$\\
$\sigma,i \vDash \neg \psi$ &ssi& $\sigma(i)$ ne vérifie pas $\phi$\\
$\sigma,i \vDash \psi_1 \land \psi_2$ &ssi& $\sigma(i)$ vérifie $\phi_1$ et $\sigma(i)$ vérifie $\phi_2$\\
$\sigma,i \vDash \psi_1 \lor \psi_2$ &ssi& $\sigma(i)$ vérifie $\phi_1$ ou $\sigma(i)$ vérifie $\phi_2$\\
$\sigma,i \vDash \mbox{EX } \psi$ &ssi& il existe un successeur de $\sigma(i)$ vérifiant $\psi$\\
$\sigma,i \vDash \mbox{AX } \psi$ &ssi& tous les successeurs de $\sigma(i)$ vérifient $\psi$\\
$\sigma,i \vDash \mbox{E } \psi_1 \mbox{ U } \psi_2$ &ssi& il existe un chemin à partir de $\sigma(i)$ tel que $\psi_1$\\&& est vrai jusqu'à ce que $\psi_2$ le soit (et il le sera un jour)\\

$\sigma,i \vDash \mbox{A } \psi_1 \mbox{ U } \psi_2$ &ssi& pour tout chemin partant de $\sigma(i)$, $\psi_1$ est vrai \\&& jusqu'à ce que $\psi_2$ le soit (et il le sera un jour)\\

$\sigma,i \vDash \mbox{E } \psi_1 \mbox{ W } \psi_2$ &ssi& il existe un chemin à partir de $\sigma(i)$ tel que $\psi_1$\\&& est vrai jusqu'à ce que, peut-être, $\psi_2$ le soit\\

$\sigma,i \vDash \mbox{A } \psi_1 \mbox{ W } \psi_2$ &ssi& pour tout chemin partant de $\sigma(i)$, $\psi_1$ est vrai \\&& jusqu'à ce que, peut-être, $\psi_2$ le soit\\
\end{tabular}

\subsection{Négation}
On peut définir la fonction $neg:CTL \to CTL$ qui permet de transformer une formule de CTL de la forme $\neg \phi$ en formule équivalente où toutes les négations sont sur les littéraux :
\begin{align*}
&neg(\top) = \bot \quad neg(\bot) = \top\\
&neg(p) = \neg p \quad neg(\neg \phi) = \phi\\
&neg(a \lor b) = neg(a) \land neg(b)\\
&neg(a \land b) = neg(a) \lor neg(b)\\
&neg(\mbox{AX } \phi) = \mbox{EX }neg(\phi)\\
&neg(\mbox{EX } \phi) = \mbox{AX }neg(\phi)\\
&neg(\mbox{E } \phi \mbox{ U } \psi) =\mbox{A } (neg(\psi)) \mbox{ W } (neg(\phi) \land neg(\psi))\\
&neg(\mbox{A } \phi \mbox{ U } \psi) =\mbox{E } (neg(\psi)) \mbox{ W } (neg(\phi) \land neg(\psi))\\
&neg(\mbox{E } \phi \mbox{ W } \psi) =\mbox{A } (neg(\psi)) \mbox{ U } (neg(\phi) \land neg(\psi))\\
&neg(\mbox{A } \phi \mbox{ W } \psi) =\mbox{E } (neg(\psi)) \mbox{ U } (neg(\phi) \land neg(\psi))
\end{align*}

\section{Model-checking de CTL: jeux faibles de parité}
Le but ici est de parvenir à créer un jeu à partir d'une formule et d'une structure de Kripke où deux joueurs (nommés Eve et Adam) s'affrontent, et Eve gagne si et seulement si la formule est vraie dans la structure donnée.

\subsection{Jeux de parité}
\label{fpg}
On appelle \emph{jeu de parité} un quadruplet $G = (V_E, V_A, R, c)$ où:
\begin{itemize}
\item $V_E$ (respectivement $V_A$) est l'ensemble des états jouables par Eve (respectivement Adam). On demande de plus que $V_e \cap V_a = \emptyset$. On note $V = V_e \sqcup V_a$.
\item $R \subseteq V \times V$ est une relation de transition.
\item $c : V \to (\mathbb{N} \cup \{\bot\})$ est une fonction qui associe une couleur ou $\bot$ à chaque état.
\end{itemize}

\subsubsection{Stratégie}
On appelle $\omega : V' \to V$ ($V' \subseteq V$) une stratégie d'un joueur si et seulement si $\forall v \in V, (v,\omega(v)) \in R$.\\
De plus, une stratégie $\omega$ est dite gagnante pour:
\begin{itemize}
	\item Eve, si et seulement si:
	\begin{itemize}
		\item Soit Adam est bloqué: $\exists v \in V'$ tel que $\omega(v) \mod 2 = 1$ et $\nexists z \in V, (\omega(v), z) \in R$.
		\item Soit Eve visite infiniment souvent uniquement des états pairs: TODO
	\end{itemize}
	\item Adam, si et seulement si:
	\begin{itemize}
		\item Soit Eve est bloquée: $\exists v \in V'$ tel que $\omega(v) \mod 2 = 2$ et $\nexists z \in V, (\omega(v), z) \in R$.
		\item Soit Adam visite infiniment souvent des états impairs: TODO
\end{itemize}
\end{itemize}

Une partie est une séquence d'états $\gamma_i$ telle que $\forall i \in I \subseteq \mathbb{N}, (\gamma_i,\gamma_{i+1}) \in R$. Si $I$ est fini, on demande alors que $\gamma_{max(I)}$ n'ait pas de successeurs par $R$.

\subsection{Jeux faibles de parité}

On dit qu'un jeu de parité $G = (V_E,V_A,R,c)$ est \emph{faible}  si et seulement si il existe $V_1$, ..., $V_k$ une partition de $V = V_E \sqcup V_A$ telle que:
\begin{enumerate}[a)]
\item La couleur soit la même pour tous les états d'une classe de la partition : $\forall i \in \llbracket 1 ; k \rrbracket$, $\forall x, y \in V_i$, $(c(x) \neq \bot \land c(y) \neq \bot)  \implies c(x) = c(y)$
\item La partition représente une convergence du jeu :\\
$\forall (x, y) \in R$, $x\in V_i, y \in V_j \Rightarrow i \leq j$.
\end{enumerate}

\subsection{Formule booléennes positives}
On définit l'ensemble des formules booléennes positives sur un ensemble $\Omega$ (noté $PBF(\Omega) $) de la manière suivante :
$\phi := \bot \mid \top \mid p \mid \psi_1 \lor \psi_2 \mid  \psi_1 \land \psi_2$

\subsection{Algorithme de construction du jeu}
Nous allons maintenant définir un algorithme qui permet de construire un jeu de parité à partir d'une formule de CTL et d'une structure de Kripke. Nous allons ensuite montrer que ce jeu est \emph{faible} et que Eve gagne si et seulement si la formule est vraie dans la structure. Plus précisément, nous allons donner ici la fonction de transition du jeu.

Soit $\phi$ une formule de CTL et $K = (Q,T,q_0,l)$  une structure de Kripke.
On va construire un jeu de parité $G = (V_E,V_A,R,c)$ où:
\begin{itemize}
	\item $V = Q \times PBF(Q \times CTL) $ %todo vérif
	\item $V_E = \{(i, \bot ) \in V\} \cup \{(i, \psi_1 \lor \psi_2) \in V \}$
	\item $V_A = V \backslash V_E$
	\item $\forall (s,v) \in V$
	\begin{itemize}
		\item Si $v \in Q \times CTL$, $c(s,v) = poids(v) \mod 2$
		\item Sinon, $c(s,v) = \bot$  %todo poids
	\end{itemize}
\end{itemize}

On peut maintenant définir $R$, la relation de transition, en définissant la fonction $succ : V \to [V]$ qui à un état associe la liste de ses successeurs.\\

On commence par définir une fonction $\tau_d : CTL \times \Omega \to V$ qui va s'occuper du cas des littéraux de $V$: TODO\\

Cela permet donc de définir $succ$:
\begin{itemize}
\item$ succ(s, \bot) = succ(s, \top) = []$
\item $succ(s,\phi \land \psi) = succ(s, \phi \lor \psi) = [(s,\phi), (s,\psi)]$
\item $succ(s,(c,q)) = [(s', \tau_{deg (s')}(q, l(s')))]$ où $s'$ est la $c$-ème transition partant de $q$ dans $T$.
\end{itemize}

\subsubsection{Jeu faible}
Montrons que le jeu définit par $succ$ et avec comme état initial $s = \tau_{deg (q_0)}(\phi, l(q_0))$.
 est un jeu \emph{faible}, donc qu'il existe une partition finie de $V$ telle que a) et b) (définies en Section \ref{fpg}) soient vraies.

On identifie le jeu à un graphe et on va montrer que la partition $V_1, \dots, V_k$ composée des composantes fortement connexes ordonnées dans un ordre topologique (les CFC forment un arbre) du jeu satisfait les conditions.

\paragraph{a)}
$\forall i \in \llbracket 1 ; k \rrbracket$, $\forall x,y \in V_i$ tel que $c(x) \neq \bot$ et $c(y) \neq \bot$. TODO

\paragraph{b)} est trivialement vraie: les $V_i$ sont ordonnées par ordre topologique.

\subsubsection{Jeu correct}
Montrons maintenant que Eve a une stratégie gagnante dans $G$ si, et seulement si, $\exists \sigma$: $\sigma,q_0 \vDash \phi$.

\paragraph{$\implies$}

\paragraph{$\Longleftarrow$}
Soit $\sigma$ tel que $\sigma,q_0 \vDash \phi$. On doit en déduire une stratégie gagnante pour Eve.\\

\subsection{Résolution des jeux faibles de parité}


\end{document}
